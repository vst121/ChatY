@using ChatY.Core.Entities
@using ChatY.Services.Interfaces
@using Microsoft.AspNetCore.SignalR.Client
@inject IMessageService MessageService
@inject NavigationManager Navigation
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

<div class="chat-window">
    <div class="chat-header">
        <h5>@ChatName</h5>
        <div class="chat-actions">
            <button class="btn btn-sm btn-link" @onclick="() => StartCall('Voice')" title="Start voice call">
                <i class="fas fa-phone"></i>
            </button>
            <button class="btn btn-sm btn-link" @onclick="() => StartCall('Video')" title="Start video call">
                <i class="fas fa-video"></i>
            </button>
            <button class="btn btn-sm btn-link"><i class="fas fa-ellipsis-v"></i></button>
        </div>
    </div>

    <div class="chat-messages" @ref="messagesContainer">
        @if (messages == null)
        {
            <div class="text-center p-4">
                <div class="spinner-border" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
            </div>
        }
        else
        {
            @foreach (var message in messages.OrderBy(m => m.SentAt))
            {
                <div class="message @(message.SenderId == currentUserId ? "message-sent" : "message-received")">
                    <div class="message-content">
                        <div class="message-header">
                            <span class="message-sender">@GetSenderName(message)</span>
                            <span class="message-time">@message.SentAt.ToString("HH:mm")</span>
                        </div>
                        <div class="message-text">@message.Content</div>
                        @if (message.Reactions.Any())
                        {
                            <div class="message-reactions">
                                @foreach (var reaction in message.Reactions.GroupBy(r => r.Emoji))
                                {
                                    <span class="reaction-badge">
                                        @reaction.Key @reaction.Count()
                                    </span>
                                }
                            </div>
                        }
                    </div>
                </div>
            }
        }
    </div>

    <div class="chat-input-container">
        <div class="typing-indicator" style="@(isTyping ? "display: block;" : "display: none;")">
            <span>@typingUserName is typing...</span>
        </div>
        <div class="chat-input">
            <button class="btn btn-link"><i class="fas fa-paperclip"></i></button>
            <input type="text" @bind="messageInput" @oninput="HandleTyping" @onkeypress="HandleKeyPress"
                placeholder="Type a message..." class="form-control" />
            <button class="btn btn-link" @onclick="SendMessage" disabled="@string.IsNullOrWhiteSpace(messageInput)">
                <i class="fas fa-paper-plane"></i>
            </button>
        </div>
    </div>
</div>

<!-- Call Window Component -->
<CallWindow @ref="callWindow" ChatId="@ChatId" CallId="@currentCallId" CallType="@currentCallType"
    OnCallEnded="HandleCallEnded" />

<!-- Call Notification -->
@if (showCallNotification)
{
    <div class="call-notification">
        <div class="call-notification-content">
            <div class="call-notification-icon">
                <i class="fas fa-phone"></i>
            </div>
            <div class="call-notification-info">
                <div class="call-notification-title">Incoming @currentCallType Call</div>
                <div class="call-notification-subtitle">From @ChatName</div>
            </div>
            <div class="call-notification-actions">
                <button class="btn btn-success btn-sm" @onclick="AcceptCall">
                    <i class="fas fa-phone"></i> Accept
                </button>
                <button class="btn btn-danger btn-sm" @onclick="DeclineCall">
                    <i class="fas fa-phone-slash"></i> Decline
                </button>
            </div>
        </div>
    </div>
}

@code {
    [Parameter] public string ChatId { get; set; } = string.Empty;
    [Parameter] public string ChatName { get; set; } = string.Empty;

    private List<Message>? messages;
    private HubConnection? hubConnection;
    private string messageInput = string.Empty;
    private string? currentUserId = "user1"; // TODO: Get from authentication
    private bool isTyping = false;
    private string? typingUserName;
    private ElementReference messagesContainer;
    private System.Threading.Timer? typingTimer;

    // Call-related fields
    private CallWindow? callWindow;
    private string currentCallId = string.Empty;
    private string currentCallType = "Voice";
    private bool showCallNotification = false;

    protected override async Task OnInitializedAsync()
    {
        await LoadMessages();
        await InitializeSignalR();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await ScrollToBottom();
        }
    }

    private async Task LoadMessages()
    {
        messages = (await MessageService.GetChatMessagesAsync(ChatId)).ToList();
        StateHasChanged();
        await ScrollToBottom();
    }

    private async Task InitializeSignalR()
    {
        hubConnection = new HubConnectionBuilder()
        .WithUrl(Navigation.ToAbsoluteUri("/chathub"))
        .Build();

        hubConnection.On<dynamic>("MessageReceived", async (messageObj) =>
        {
            await LoadMessages();
            StateHasChanged();
        });

        hubConnection.On<dynamic>("UserTyping", (typingObj) =>
        {
            // Handle typing indicator
            isTyping = true;
            typingUserName = typingObj.UserName;
            StateHasChanged();
        });

        hubConnection.On<dynamic>("UserStoppedTyping", (typingObj) =>
        {
            isTyping = false;
            typingUserName = null;
            StateHasChanged();
        });

        // Call event handlers
        hubConnection.On<dynamic>("CallStarted", async (callData) =>
        {
            await HandleIncomingCall(callData);
        });

        await hubConnection.StartAsync();
        await hubConnection.SendAsync("JoinChat", ChatId);
    }

    private async Task SendMessage()
    {
        if (string.IsNullOrWhiteSpace(messageInput) || hubConnection == null)
            return;

        await hubConnection.SendAsync("SendMessage", ChatId, messageInput, "Text");
        messageInput = string.Empty;
        await LoadMessages();
    }

    private async Task HandleKeyPress(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !e.ShiftKey)
        {
            await SendMessage();
        }
    }

    private async Task HandleTyping()
    {
        if (hubConnection != null && !isTyping)
        {
            await hubConnection.SendAsync("StartTyping", ChatId);
            isTyping = true;
        }

        // Reset the timer
        typingTimer?.Dispose();
        typingTimer = new System.Threading.Timer(async _ =>
        {
            if (hubConnection != null)
            {
                await hubConnection.SendAsync("StopTyping", ChatId);
                isTyping = false;
                typingUserName = null;
                await InvokeAsync(StateHasChanged);
            }
        }, null, 3000, Timeout.Infinite);
    }

    private string GetSenderName(Message message)
    {
        return message.Sender?.DisplayName ?? message.Sender?.UserName ?? "Unknown";
    }

    private async Task ScrollToBottom()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("scrollToBottom", messagesContainer);
        }
        catch { }
    }

    // Call methods
    private async Task StartCall(string callType)
    {
        if (callWindow == null) return;

        currentCallType = callType;
        await callWindow.StartCall();
    }

    private async Task HandleIncomingCall(dynamic callData)
    {
        var callId = callData.Id;
        var callType = callData.CallType;
        var initiatorId = callData.InitiatorId;

        // Don't show notification if we're the initiator
        if (initiatorId == currentUserId)
            return;

        currentCallId = callId;
        currentCallType = callType;
        showCallNotification = true;
        StateHasChanged();
    }

    private async Task HandleCallEnded(bool ended)
    {
        currentCallId = string.Empty;
        currentCallType = "Voice";
        showCallNotification = false;
        StateHasChanged();
    }

    private async Task AcceptCall()
    {
        if (callWindow == null || string.IsNullOrEmpty(currentCallId)) return;

        showCallNotification = false;
        await callWindow.JoinCall(currentCallId);
        StateHasChanged();
    }

    private void DeclineCall()
    {
        currentCallId = string.Empty;
        currentCallType = "Voice";
        showCallNotification = false;
        StateHasChanged();
    }

    public async ValueTask DisposeAsync()
    {
        typingTimer?.Dispose();
        if (hubConnection is not null)
        {
            await hubConnection.SendAsync("LeaveChat", ChatId);
            await hubConnection.DisposeAsync();
        }
    }
}

<style>
.call-notification {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 1050;
    min-width: 350px;
}

.call-notification-content {
    background: white;
    border-radius: 8px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.15);
    display: flex;
    align-items: center;
    padding: 16px;
    gap: 16px;
}

.call-notification-icon {
    width: 40px;
    height: 40px;
    background: #007bff;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-size: 18px;
}

.call-notification-info {
    flex: 1;
}

.call-notification-title {
    font-weight: 600;
    font-size: 14px;
    margin-bottom: 4px;
}

.call-notification-subtitle {
    font-size: 12px;
    color: #6c757d;
}

.call-notification-actions {
    display: flex;
    gap: 8px;
}
</style>